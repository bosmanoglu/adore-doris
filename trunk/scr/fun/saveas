#!/bin/bash
# USAGE:
#	saveas exportFormat [optionalParameters] processName
#
# DESCRIPTION:
#  SAVEAS is an internal ADORE command. 
#  It prepares DORIS results so that they can be opened by other programs. 
#  Currently ENVI and ArcGIS are supported. 
#
# INPUT:
#  exportFormat: envi or arcgis. 
#  processName: Doris step to be exported.
#  
#  Optional:
#    saveas arcgis [a|p|m] processName
#	arcgis export files (HFA, img files) can only have single channel (amplitude, phase or mixed).
#       If not specified p(phase) is assumed. This can be used to export amplitude data as well if 
#	you do not want to rescale the amplitude values. 
#
# OUTPUT:
#  Generates an HDR file with the same name as the output file of the requested doris step (processName).
#

# $0 dorisStep  
function saveas_envi(){
  local dorisStep=${1}
  local geocodeStatus phi_filename lam_filename phi_l0p0 lam_l0p0 phi_lNpN lam_lNpN phi_step lam_step
  local filename resfile format numpixels numlines hei_filename hei_resfile hei_format hei_numpixels hei_numlines
  local bands rotation phi_lNp0 
  geocodeStatus=`check ${i_resfile} | grep -i -w "geocoding"| cut -f2 -d:`
  if [ ${geocodeStatus} -eq "1" ]; then
    call "(filename resfile format numpixels numlines)=dorisProcess2OutputFile ${dorisStep}"
    call "(hei_filename hei_resfile hei_format hei_numpixels hei_numlines)=dorisProcess2OutputFile geocode Data_output_file_hei"
    # get the name of phi(lat) and lambda (lon) files
    phi_filename=`readRes.sh ${i_resfile} geocoding Data_output_file_phi`
    lam_filename=`readRes.sh ${i_resfile} geocoding Data_output_file_lamda`
    #get the coordinates for 1st px
    phi_l0p0=`cpxfiddle -w ${hei_numpixels} -f ${hei_format} -qnormal -l1 -L1 -p1 -P1 ${phi_filename} 2>/dev/null | tr -d "\n"`
    lam_l0p0=`cpxfiddle -w ${hei_numpixels} -f ${hei_format} -qnormal -l1 -L1 -p1 -P1 ${lam_filename} 2>/dev/null | tr -d "\n"`
    #get the coordinates for last px on 1st line
    # lam = longitude so divide by numpix
    lam_l0pN=`cpxfiddle -w ${hei_numpixels} -f ${hei_format} -qnormal -l1 -L1 -p${hei_numpixels} -P${hei_numpixels} ${lam_filename} 2>/dev/null | tr -d "\n"`
    lam_step=`echo "${lam_l0pN} ${lam_l0p0} ${numpixels}" | awk '{printf "%e", ($1-$2)/$3};'`
    #get the coordinates for last line on 1st col.(pixel)
    # phi is latitude so divide by numlines
    phi_lNp0=`cpxfiddle -w ${hei_numpixels} -f ${hei_format} -qnormal -l${hei_numlines} -L${hei_numlines} -p1 -P1 ${phi_filename} 2>/dev/null | tr -d "\n"`        
	# Below line has a problem without -1 multiplier in Envi. 
    phi_step=`echo "${phi_lNp0} ${phi_l0p0} ${numlines}"  | awk '{printf "%e", -1*($1-$2)/$3};'` 
    #calculate rotation
    lam_lNp0=`cpxfiddle -w ${hei_numpixels} -f ${hei_format} -qnormal -l${hei_numlines} -L${hei_numlines} -p1 -P1 ${lam_filename} 2>/dev/null | tr -d "\n"`
    rotation=`echo "${phi_lNp0} ${phi_l0p0} ${lam_lNp0} ${lam_l0p0}" | awk '{PI=3.1415;printf "%.8f", 90+(atan2($1-$2, $3-$4)*180/PI)};'`
    #change format to envi 
    [ ${format} == "cr4" ] && format="4" && bands="2"
    [ ${format} == "ci2" ] && format="2" && bands="2"
    [ ${format} == "r4" ] && format="4"  && bands="1"
    [ ${format} == "i2" ] && format="2"  && bands="1"
cat > ${filename}.hdr <<_EndHere
ENVI
description = {DORIS ${dorisStep} output: ${filename}}
samples = ${numpixels}
lines   = ${numlines}
bands   = ${bands}
header offset = 0
file type = ENVI Standard
data type = ${format}
interleave = bip
sensor type = Unknown
byte order = 0
map info = {Geographic Lat/Lon, 1.5000, 1.5000, ${lam_l0p0}, ${phi_l0p0}, ${lam_step}, ${phi_step}, WGS-84, units=Degrees, rotation=${rotation}}
default bands = {1}
wavelength units = Unknown

_EndHere
#    band names = {}
    echo "ENVI header file: ${filename}.hdr"
    echo "SUCCESS: saveas_envi"
  else
    echo "Please first do the geocoding step to export to ENVI."
  fi
}

function saveas_arcgis(){
  dorisStep=${1}
  local geocodeStatus phi_filename lam_filename phi_l0p0 lam_l0p0 phi_lNpN lam_lNpN phi_step lam_step
  local filename resfile format numpixels numlines hei_filename hei_resfile hei_format hei_numpixels hei_numlines
  local bands endian

  geocodeStatus=`check ${i_resfile} | grep -i -w "geocoding"| cut -f2 -d:`
  if [ ${geocodeStatus} -eq "1" ]; then
    call "(filename resfile format numpixels numlines)=dorisProcess2OutputFile ${dorisStep}"
    call "(hei_filename hei_resfile hei_format hei_numpixels hei_numlines)=dorisProcess2OutputFile geocode Data_output_file_hei"
    # get the name of phi(lat) and lambda (lon) files
    phi_filename=`readRes.sh ${i_resfile} geocoding Data_output_file_phi`
    lam_filename=`readRes.sh ${i_resfile} geocoding Data_output_file_lamda`
    #get the coordinates for 1st px
    phi_l0p0=`cpxfiddle -w ${hei_numpixels} -f ${hei_format} -qnormal -l1 -L1 -p1 -P1 ${phi_filename} 2>/dev/null | tr -d "\n"`
    lam_l0p0=`cpxfiddle -w ${hei_numpixels} -f ${hei_format} -qnormal -l1 -L1 -p1 -P1 ${lam_filename} 2>/dev/null | tr -d "\n"`
    #get the coordinates for last px on 1st line
    phi_l0pN=`cpxfiddle -w ${hei_numpixels} -f ${hei_format} -qnormal -l1 -L1 -p${hei_numpixels} -P${hei_numpixels} ${phi_filename} 2>/dev/null | tr -d "\n"`
    phi_step=`echo "${phi_l0pN} ${phi_l0p0} ${numpixels}" | awk '{printf "%.8f", ($1-$2)/$3};'`
    #get the coordinates for last line on 1st col.(pixel)
    lam_lNp0=`cpxfiddle -w ${hei_numpixels} -f ${hei_format} -qnormal -l${hei_numlines} -L${hei_numlines} -p1 -P1 ${lam_filename} 2>/dev/null | tr -d "\n"`        
    lam_step=`echo "${lam_lNp0} ${lam_l0p0} ${numlines}"  | awk '{printf "%.8f", ($1-$2)/$3};'`
    #change format to arcgis
    [ ${format} == "cr4" ] && format="32" && bands="2"
    [ ${format} == "ci2" ] && format="16" && bands="2"
    [ ${format} == "r4" ] && format="32"  && bands="1"
    [ ${format} == "i2" ] && format="16"  && bands="1"
    endian=`getSystemEndianness`
    [ ${endian} == "little" ] && endian="I"
    [ ${endian} == "big"    ] && endian="M"
cat > ${filename}.hdr <<_EndHere
BYTEORDER	${endian}
LAYOUT		BIP
NROWS		${numlines}
NCOLS		${numpixels}
NBANDS		${bands}
NBITS		${format}
NODATA		-9999
ULXMAP		${phi_l0p0}
ULYMAP		${lam_l0p0}
XDIM		${phi_step}
YDIM		%{lam_step}
_EndHere
    #xllcorner     0
    #yllcorner     0
    echo "ArcGIS header file: ${filename}.hdr"
    echo "SUCCESS: saveas_arcgis"
  else
    echo "Please first do the geocoding step to export to ArcGIS."
  fi
}


function saveas_arcgis_gdal(){
  local generate dorisStep geocodeStatus filename resfile format numpixels numlines hei_filename hei_resfile hei_format hei_numpixels hei_numlines
  local generateCheck phi_filename lam_filename slc_rg_res_km slc_az_res_km center_lat center_lon slc_res_deg region 
  local inc_angle radar_band_width
 
  if [ ${2:-undefined} == "undefined" ]; then
    generate="a"; echo "You only specified one parameter. I'm assuming you wanted (p)phase output."
    dorisStep=${1}
  else
    generate=${1}
    dorisStep=${2}
  fi

  geocodeStatus=`check ${i_resfile} | grep -i -w "geocoding"| cut -f2 -d:`
  if [ ${geocodeStatus} -eq "1" ]; then
    call "(filename resfile format numpixels numlines)=dorisProcess2OutputFile ${dorisStep}"
    echo "..width..${numpixels}.."
    echo "..format..${format}.."
    call "(hei_filename hei_resfile hei_format hei_numpixels hei_numlines)=dorisProcess2OutputFile geocode Data_output_file_hei"
    # get the name of phi(lat) and lambda (lon) files
    phi_filename=`readRes.sh ${i_resfile} geocoding Data_output_file_phi`
    lam_filename=`readRes.sh ${i_resfile} geocoding Data_output_file_lamda`

    #generate file (amplitude, phase) to export
    generate=`echo ${generate} | tr [:upper:] [:lower:]`
    if [ "${#generate}" -gt "1" ]; then
      echo "I can only convert one product (a-amplitude, p-phase or m-mixed) at a time."
      return;
    fi
    generateCheck=`echo ${generate} | tr -d [a,p,m]`
    if [ -z ${generateCheck} ]; then
      echo -n "You requested me to generate: "
      [ ${generate} == 'a' ] && echo "amplitude"
      [ ${generate} == 'p' ] && echo "phase"
      [ ${generate} == 'm' ] && echo "mixed"
    else
      echo "I can only create phase(p), amplitude(a) or mixed(m) images."
      echo "You provided some extra options: ${generateCheck}"
      return -1;
    fi
    if [ -z ${filename} ]; then
      echo "No data file for the step ${dorisStep} in ${resfile}"
      return;
    fi
    outName=`basename ${filename}| tr '.' '_'`
    if [[ "${generate}" == *a* ]]; then
      if [[ ${#format} -eq 2 ]];then
        cpxfiddle -w ${numpixels} -f ${format} -e 0.5 -q normal -o float ${filename} > ${outName}.temporary || { echo "Error running command: $_"; return 1; }
      else
        cpxfiddle -w ${numpixels} -f ${format} -e 0.5 -q mag  -o float   ${filename} > ${outName}.temporary || { echo "Error running command: $_"; return 1; }
      fi
    elif [[ "${generate}" == *p* ]]; then
      if [[ ${#format} -eq 2 ]];then
        cpxfiddle -w ${numpixels} -f ${format} -q normal -o float ${filename} > ${outName}.temporary || { echo "Error running command: $_"; return 1; }
      else 
        cpxfiddle -w ${numpixels} -f ${format} -q phase  -o float ${filename} > ${outName}.temporary || { echo "Error running command: $_"; return 1; }
      fi
    elif [[ "${generate}" == *m* ]]; then
      if [[ ${#format} -eq 2 ]];then
        echo "Mixed (Amp/Phase) output can not be generated using a real file. Image format: ${format}"
      else
        cpxfiddle -w ${numpixels} -f ${format} -e 0.5 -s 1.2 -o float ${filename} > ${outName}.temporary || { echo "Error running command: $_"; return 1; }
      fi
    fi

    #generate a 3 column data file combining phi lam hei
    gmtconvert ${lam_filename} ${phi_filename} ${outName}.temporary -bis1 -A -bos3 > ${outName}.dat
    #get pixel size in degrees
	#################DUPLICATED CODE FROM scr/fun/dem. Make lines below a function
        radar_band_width=`readRes.sh ${m_resfile} readfiles Total_range_band_width | tr -d '\n'`
        echo "Radar Band Width=${radar_band_width}"
        if [ -e ${i_resfile} ]; then
          inc_angle=`readRes.sh ${i_resfile} coarse_orbits inc_angle | tr -d '\n'`
        fi
        [ -z "${inc_angle}" ] && echo -e "Can not read incidence angle from ${i_resfile}. \n Using default:23.2" && inc_angle=23.2
        # get range resolution
        [ -z "${slc_rg_res}" ] && slc_rg_res=`echo "2.99e8 ${radar_band_width} ${inc_angle}" | awk '{PI=3.14159;printf "%d", $1/($2*1e6*cos($3/180*PI))};'`
        [ -z "${slc_az_res}" ] && slc_az_res=`echo "${slc_rg_res}" | awk '{printf "%d", $1/5};'`
        echo "SLC resolution [Azimuth x Range]: ${slc_az_res} x ${slc_rg_res}"
	#################END DUPLICATE
    dorisStep=`pn2rs ${2}`  #readRes.sh does not call pn2rs automatically...
    rg_multilooking=`${ADORESCR}/readRes.sh ${i_resfile} ${dorisStep} "Multilookfactor_range_direction"`    
    az_multilooking=`${ADORESCR}/readRes.sh ${i_resfile} ${dorisStep} "Multilookfactor_azimuth_direction"`    
    slc_rg_res_km=`echo "${slc_rg_res} ${rg_multilooking}" | awk '{printf "%f", $1*$2/1000};'`
    slc_az_res_km=`echo "${slc_az_res} ${az_multilooking}" | awk '{printf "%f", $1*$2/1000};'`	
    ## get center coordinates
    center_lat=`readRes.sh ${m_resfile} readfiles Scene_centre_latitude | tr -d '\n'`
    center_lon=`readRes.sh ${m_resfile} readfiles Scene_centre_longitude | tr -d '\n'`
    slc_res_deg=`${ADORESCR}/km2deg.sh ${center_lat} ${center_lon} ${slc_az_res_km} ${slc_rg_res_km}`
    [ $? -ne 0 ] && echo "Error running command: ${ADORESCR}/km2deg.sh ${center_lat} ${center_lon} ${slc_az_res_km} ${slc_rg_res_km}" && return 1
    slc_res_deg=${slc_res_deg/ /\/}
    #need to get the region for gmt 
    region=`minmax -I${slc_res_deg} -bis3 ${outName}.dat` 
    [ $? -ne 0 ] && echo "Error running command: minmax -I${slc_res_deg} -bis3 ${outName}.dat" && return 1
    #generate grd file
    xyz2grd ${outName}.dat -bis3 -G${outName}.grd ${region} -I${slc_res_deg} -N32767 -V || { echo "Error running command: $_"; return 1; }
    #change grid to the older format (gdal complienat)
    grdreformat ${outName}.grd ${outName}_grdreformat.grd=sf -V || { echo "Error running command: $_"; return 1; }
    #translate the grd to HFA(img) format using gdal
    gdal_translate -a_nodata 32767 -co "STATISTICS=YES" -of HFA ${outName}_grdreformat.grd ${outName}.img 
    if [ $? -ne 0 ]; then
      echo "gdal_translate failed. I was trying to run: gdal_translate -a_nodata 32767 -co "STATISTICS=YES" -of HFA ${outName}_grdreformat.grd ${outName}.img";
      echo "I might have left behind temporary files: ${outName}.temporary ${outName}_grdreformat.grd ${outName}.grd ${outName}.dat"
      return
    else
      #cleanup
      rm -rf ${outName}.temporary ${outName}_grdreformat.grd ${outName}.grd ${outName}.dat
      echo "ArcGIS filename: ${outName}.img"
      echo "SUCCESS: saveas_arcgis"
    fi
  else
    echo "Please first do the geocoding step to export to ArcGIS."
  fi
}






case ${1} in 
  envi)
    saveas_envi ${2}    
  ;;
  arcgis)
    saveas_arcgis_gdal ${2} ${3}
  ;;
esac
