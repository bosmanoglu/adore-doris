#!/bin/bash
# USAGE:
#	mask processName
#
# DESCRIPTION:
#  MASK is an internal ADORE command.  
#  It reads the mask file generated by snaphu, and masks the given process name.
#
# INPUT:
#  processName: 
#	name of doris step to be masked. (i.e. interfero, subtrrefpha,
#       subtrrefdem, filtphase)
#
# OUTPUT:
#   MASK will automatically rename the original DORIS output to
#   filename.notmasked
#   The masked file will be named as the original output. 
#   

function applyMask(){
local dorisStep threshold mask_file coherence_file doris_output resFile format width numlines
#read input
dorisStep=`pn2rs ${1}`
if [ -z "${2}" ]; then
  mask_file=`readRes.sh ${i_resfile} unwrap Data_output_file`
  mask_file="${mask_file}.mask"
  [ ! -e ${mask_file} ] && echo "Mask file does not exist: ${mask_file}" && return
  # generate float mask
  bkconvert ${mask_file} ${mask_file}.float 1 4 &> /dev/null
  [ ! -e ${mask_file}.float ] && echo "Float mask file could not be created.: ${mask_file}.float" && echo "I was trying to run: bkconvert ${mask_file} ${mask_file}.float 1 4" && return
  mask_file=${mask_file}.float
else
  mask_file="${2}"
fi
[ ! -e ${mask_file} ] && echo "Mask file does not exist: ${mask_file}" && echo "Please create a mask file first." && return

# get the name of the output file for doris step.
call "(doris_output resFile format width numlines)=dorisProcess2OutputFile ${dorisStep}"
echo "Backing-up ${doris_output} to ${doris_output}.notmasked"
mv ${doris_output} ${doris_output}.notmasked
if [ "${format}" == "r4" ]; then
  gmtmath -bis1 -bos1 ${mask_file} ${doris_output}.notmasked MUL = ${doris_output} &> /dev/null
elif [ "$format" == "cr4" ]; then
  #generate complex mask
  if [ ! -e ${mask_file}.cpx ]; then   
    echo "Complex masking operation adds a constant phase value of PI/4 to the whole image. Should not effect results/modeling etc."
    gmtconvert ${mask_file} ${mask_file} -bis1 -A -bos2 > ${mask_file}.cpx
    [ ! -e ${mask_file}.cpx ] && echo "Complex mask file could not be created.: ${mask_file}.cpx" && echo "I was trying to run: gmtconvert ${mask_file} ${mask_file} -bis1 -A -bos2 > ${mask_file}.cpx" && return
  fi
  #cpxmult ${doris_output}.notmasked ${mask_file}.cpx ${doris_output} add=1
  gmtmath -bis1 -bos1 ${mask_file}.cpx ${doris_output}.notmasked MUL = ${doris_output}
else
  echo "Output format of the file you requested is ${format}. I can only mask real4 (r4) or complex_real4 (cr4) files."
  return
fi
  
if [ ! -e ${doris_output} ]; then
  echo "There was a problem with applying the mask."
  [ "${format}" == "r4" ] &&  echo "I was trying to run: gmtmath -bis1 -bos1 ${mask_file}.float ${doris_output}.notmasked MUL = ${doris_output}"
  [ "${format}" == "cr4" ] && echo "cpxmult ${doris_output}.notmasked ${mask_file}.float ${doris_output} add=1"
  mv ${doris_output}.notmasked ${doris_output}
  return
fi

echo "Original file in: ${doris_output}.notmasked"
echo "Masked output file: ${doris_output}"
echo "SUCCESS: mask"
}


function generateMask(){
local dorisStep threshold mask_file input_file doris_output resFile format width numlines
local operation
#read input
if [ -z "${2}" ]; then
  input_file="${coh_out_coh}" # `readRes.sh ${i_resfile} coherence Data_output_file`
  operation='lt'
  threshold=${1:-0.4}
else
  input_file="${1}"
  operation="${2}"
  threshold=${3}
fi

#generate mask
floatmask ${input_file} ${operation} ${threshold}
if [ $? -ne 0 ]; then
  echo "floatmask command failed. I can not continue without the mask file."
  return
fi
# get floatmask filename
mask_file=${input_file}.${operation}${threshold}
[ ! -e ${mask_file} ] && echo "Mask file does not exist: ${mask_file}" && return

echo "Mask is ready: ${mask_file}"
}

case ${1} in 
  generate)
    shift
    generateMask ${@}
  ;;
  *)
    applyMask ${@}
  ;;
esac

#generateMask $@
#applyMask $@